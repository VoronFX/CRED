@using CRED.Controllers
<script type="text/javascript">

    function makeRequest(method, url) {
        return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open(method, url);
            xhr.onloadend = function() {
                resolve(xhr);
            };
            xhr.send();
        });
    }

    function getResUrl(node, type) {
        switch (type) {
        case "css":
            return node.href;
        case "js":
            return node.src;
        default:
            throw "Unsupported resource";
        }
    }

    function createNode(url, resBlockNode, type) {
        switch (type) {
        case "css":
            return new Promise((resolve, reject) => {
                const link = document.createElement("link");
                link.src = url;
                link.addEventListener('load', resolve);
                link.addEventListener('error', () => reject('Error loading script.'));
                link.addEventListener('abort', () => reject('Script loading aborted.'));
                link.href = url;
                link.rel = "stylesheet";
                resBlockNode.appendChild(link);
            });
        case "js":
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.async = true;
                script.src = url;
                script.addEventListener('load', resolve);
                script.addEventListener('error', () => reject('Error loading script.'));
                script.addEventListener('abort', () => reject('Script loading aborted.'));
                resBlockNode.appendChild(script);
            });
        default:
            return Promise.reject("Unsupported resource");
        }
    }

    function processManifest(newResources, resBlockNode, index) {
        return new Promise((resolve, reject) => {
            if (index >= newResources.length) {
                resolve();
                return;
            }
            const type = resBlockNode.getAttribute("data-resource-type");

            while (index < resBlockNode.children.length &&
                getResUrl(resBlockNode.children[index], type) !== newResources[index]) {
                resBlockNode.removeChild(resBlockNode.children[index]);
            }
            if (index <= resBlockNode.children.length) {
                createNode("/@ClientApp.AppAssemblyName/" + newResources[index], resBlockNode, type)
                    .then(() => processManifest(newResources, resBlockNode, index + 1)
                        .then(resolve));
            }
        });
    }

    function updateResourceBlocks(resBlockNodes, index) {
        return new Promise((resolve, reject) => {
            if (index >= resBlockNodes.length) {
                resolve();
                return;
            }
            const resBlockNode = resBlockNodes[index];

            if (!resBlockNode.hasAttribute("data-hmt-resource"))
                updateResourceBlocks(resBlockNodes, index + 1)
                    .then(resolve);
            else {

                makeRequest("GET", resBlockNode.getAttribute("data-manifest-src"))
                    .then(xhr => {
                        if (xhr.status === 200) {

                            if (resBlockNode.getAttribute("data-manifest") !== xhr.responseText) {
                                if (resBlockNode.getAttribute("data-hotswap") ||
                                    !resBlockNode.hasAttribute("data-manifest")) {
                                    resBlockNode.setAttribute("data-manifest", xhr.responseText);
                                    const manifest = JSON.parse(xhr.responseText);

                                    processManifest(manifest.Resources, resBlockNode, 0)
                                        .then(() => updateResourceBlocks(resBlockNodes, index + 1)
                                            .then(resolve)
                                        );

                                } else {
                                    window.location.reload(true);
                                }
                            } else {
                                updateResourceBlocks(resBlockNodes, index + 1)
                                    .then(resolve);
                            }
                        }
                    });
            }
        });
    }

    function watch() {
        return new Promise((resolve, reject) => {
            makeRequest("GET", "/@nameof(LongPollingFileWatcher)/@ClientApp.AppAssemblyName/**/*.manifest.json")
                .then(xhr => {
                    if (xhr.status === 200) {
                        resolve();
                    } else {
                        setTimeout(() => watch().then(() => resolve()), 1000);
                    }
                });
        });
    }

    function updateResources() {
        updateResourceBlocks(Array.from(document.getElementsByTagName("div")), 0)
            .then(() => watch()
                .then(() => updateResources()));
    }

    window.addEventListener("load", updateResources);

</script>