using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

public class Startup
{
    internal static IEnumerable<string> GeneratedHeader => @"
				//------------------------------------------------------------------------------
				// <auto-generated>
				//     This code was generated by a tool.
				//
				//     Changes to this file may cause incorrect behavior and will be lost if
				//     the code is regenerated.
				// </auto-generated>
				//------------------------------------------------------------------------------
			".UnindentVerbatim();

    public Task<object> Invoke(object input)
    {
        dynamic inputData = input;

        var css = (string)inputData.source;
        css = Regex.Replace(css, @"(?is)\{.*?\}", " ");
        css = Regex.Replace(css, @"(?i)//.*?", " ");
        css = Regex.Replace(css, @"(?is)/\*.*?\*/", " ");

        var classes =
            new HashSet<string>(
                    Regex.Matches(css, @"(?is)\.[A-Z_a-z0-9-]+").Cast<Match>().Select(x => x.Value.Substring(1)))
                .Select(x => new ValueMapItem(x, x, null));

        var valueMap = GenerateValueMap(
            (string)((IDictionary<string, object>)inputData)["namespace"],
            inputData.className,
            classes);

        return Task.FromResult(string.Join(Environment.NewLine, valueMap));
    }

    internal static IEnumerable<string> Flatten(params IEnumerable<string>[] lines)
    {
        return lines.SelectMany(x => x);
    }

    internal static ValueMapItem FromClasses(string cssClassName, IEnumerable<string> files)
    {
        return new ValueMapItem(
            cssClassName,
            cssClassName,
            new[] { cssClassName, "Referenced in next css files:" }.Concat(files.Distinct()).ToArray());
    }

    internal static IEnumerable<string> GenerateValueMap(
        string @namespace,
        string className,
        IEnumerable<ValueMapItem> items)
    {
        var itemsConsts = items.SelectMany(
            item => new[] { string.Empty, }
                .Concat(
                    item.Comment == null || !item.Comment.Any()
                        ? Enumerable.Empty<string>()
                        : new[] { "/// <summary>" }.Concat(item.Comment.Select(x => "/// " + x.XmlEscape()))
                            .Concat(new[] { "/// </summary>", })).Concat(
                    new[]
                        {
                            string.Format(
                                "public const string {0} = {1};",
                                item.Name.ToPascalCaseIdentifier(),
                                item.Value.ToVerbatimLiteral())
                        }));

        var mapClass = new[] { string.Empty, string.Format("public static class {0}", className), "{", }
            .Concat(itemsConsts.Indent()).Concat(new[] { "}" });

        return Flatten(
            GeneratedHeader,
            new[] { string.Empty, string.Format("namespace {0}", @namespace), "{", },
            mapClass.Indent(),
            new[] { "}" });
    }

    internal class ValueMapItem
    {
        public ValueMapItem(string name, string value, string[] comment)
        {
            this.Name = name;
            this.Value = value;
            this.Comment = comment;
        }

        public string[] Comment { get; private set; }

        public string Name { get; private set; }

        public string Value { get; private set; }
    }
}

internal static class ExtensionMethods
{
    public static string Flatten(this IEnumerable<string> strings)
    {
        return string.Join(Environment.NewLine, strings);
    }

    public static IEnumerable<string> Indent(this IEnumerable<string> input)
    {
        return input.Select(x => "    " + x);
    }

    public static string ToPascalCaseIdentifier(this string name)
    {
        var result = Regex.Replace("-" + name, "(?si)[^A-Za-z0-9]+", "-");
        result = Regex.Replace(result, "(?si)-+([A-Za-z0-9]?)", x => x.Groups[1].Value.ToUpperInvariant());
        if (!char.IsLetter(result[0])) result = "_" + result;
        return result;
    }

    public static string ToVerbatimLiteral(this string input)
    {
        return string.Format(@"@""{0}""", input.Replace("\"", "\"\""));
    }

    public static IEnumerable<string> UnindentVerbatim(this string input)
    {
        var splitted = input.Replace("\r\n", "\n").Split('\n');
        var indent = splitted.Where(x => !string.IsNullOrWhiteSpace(x)).Select(x => x.Length - x.TrimStart().Length)
            .Min();

        return splitted.Select(x => string.IsNullOrWhiteSpace(x) ? x : x.Substring(indent));
    }

    public static string XmlEscape(this string input)
    {
        return System.Security.SecurityElement.Escape(input);
    }
}