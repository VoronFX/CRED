using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;

public class Startup
{
	public async Task<object> Invoke(object input)
	{
		dynamic inputData = input;

		var css = (string)inputData.source;
		css = Regex.Replace(css, @"(?is)\{.*?\}", " ");
		css = Regex.Replace(css, @"(?i)//.*?", " ");
		css = Regex.Replace(css, @"(?is)/\*.*?\*/", " ");
		
		var classes = new HashSet<string>(Regex.Matches(css, @"(?is)\.[A-Z_a-z0-9-]+")
			.Cast<Match>()
			.Select(x => x.Value.Substring(1)))
			.Select(x => new ValueMapItem(x, x, null));

		return string.Join(Environment.NewLine, 
			GenerateValueMap((string)((IDictionary<string, object>)inputData)["namespace"], inputData.className, classes));
	}

	internal static ValueMapItem FromClasses(string cssClassName, IEnumerable<string> files)
	{
		return new ValueMapItem(cssClassName, cssClassName, new[] {cssClassName, "Referenced in next css files:"}
			.Concat(files.Distinct())
			.ToArray());
	}

	internal static IEnumerable<string> GenerateValueMap(string @namespace, string className,
		IEnumerable<ValueMapItem> items)
	{
		var itemsConsts = items
			.SelectMany(item => new[]
				{
					string.Empty,
				}
				.Concat(item.Comment == null || !item.Comment.Any()
					? Enumerable.Empty<string>()
					: new[]
						{
							"/// <summary>"
						}
						.Concat(item.Comment.Select(x =>
							"/// " + x.XmlEscape()
						))
						.Concat(new[]
						{
							"/// </summary>",
						}))
				.Concat(new[]
				{
					string.Format("public const string {0} = {1};", item.Name.ToPascalCaseIdentifier(), item.Value.ToVerbatimLiteral())
				}));

		var mapClass = new[]
			{
				string.Empty,
				string.Format("public static class {0}", className),
				"{",
			}
			.Concat(itemsConsts.Indent())
			.Concat(new[]
			{
				"}"
			});

		return Flatten(
			GeneratedHeader,
			new[]
			{
				string.Empty,
				string.Format("namespace {0}", @namespace),
				"{",
			},
			mapClass.Indent(),
			new[]
			{
				"}"
			});
	}

	internal static IEnumerable<string> Flatten(params IEnumerable<string>[] lines)
	{
		return lines.SelectMany(x => x);
	}

	internal static IEnumerable<string> GeneratedHeader
	{
		get
		{
			return @"
				//------------------------------------------------------------------------------
				// <auto-generated>
				//     This code was generated by a tool.
				//
				//     Changes to this file may cause incorrect behavior and will be lost if
				//     the code is regenerated.
				// </auto-generated>
				//------------------------------------------------------------------------------
			".UnindentVerbatim();
		}
	}

	internal class ValueMapItem
	{
		public ValueMapItem(string name, string value, string[] comment)
		{
			Name = name;
			Value = value;
			Comment = comment;
		}

		public string Name { get; private set; }
		public string Value { get; private set; }
		public string[] Comment { get; private set; }
	}
}

internal static class ExtensionMethods
{
	public static string XmlEscape(this string input)
	{
		return System.Security.SecurityElement.Escape(input);
	}

	public static string ToPascalCaseIdentifier(this string name)
	{
		var result = Regex.Replace("-" + name, "(?si)[^A-Za-z0-9]+", "-");
		result = Regex.Replace(result, "(?si)-+([A-Za-z0-9]?)",
			x => x.Groups[1].Value.ToUpperInvariant());
		if (!char.IsLetter(result[0]))
			result = "_" + result;
		return result;
	}

	public static string ToVerbatimLiteral(this string input)
	{
		return string.Format(@"@""{0}""", input.Replace("\"", "\"\""));
	}

	public static IEnumerable<string> Indent(this IEnumerable<string> input)
	{
		return input.Select(x => "    " + x);
	}

	public static string Flatten(this IEnumerable<string> strings)
	{
		return String.Join(Environment.NewLine, strings);
	}

	public static IEnumerable<string> UnindentVerbatim(this string input)
	{
		var splitted = input.Replace("\r\n", "\n").Split('\n');
		var indent = splitted
			.Where(x => !String.IsNullOrWhiteSpace(x))
			.Select(x => x.Length - x.TrimStart().Length)
			.Min();

		return splitted.Select(x => String.IsNullOrWhiteSpace(x) ? x : x.Substring(indent));
	}
}

